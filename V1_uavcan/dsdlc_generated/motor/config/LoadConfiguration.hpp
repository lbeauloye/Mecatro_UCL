/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/westornd/Documents/UCL/Q7/ELME2002/CVRA/C/motor/config/210.LoadConfiguration.uavcan
 */

#ifndef MOTOR_CONFIG_LOADCONFIGURATION_HPP_INCLUDED
#define MOTOR_CONFIG_LOADCONFIGURATION_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

#include <motor/config/PID.hpp>

/******************************* Source text **********************************
#
# This is usually the first command that is sent to the motor controller.
# All other commands except Get ID are ignored until this command is sent.
#

PID position_pid
PID velocity_pid
PID current_pid

float16 torque_limit            # [Nm]
float16 velocity_limit          # [rad/s]
float16 acceleration_limit      # [rad/s^2]
float16 low_batt_th             # [V] low battery threshold

float16 thermal_capacity        # [J/K]
float16 thermal_resistance      # (to ambient which is assumed 25degC) [K/W]
float16 thermal_current_gain    # (coil_resistance) [ohm = W/A^2]
float16 max_temperature         # [degC]

float16 torque_constant         # (of motor without transmission) [Nm/A]

uint16 transmission_ratio_p                 # (output/motor)
uint16 transmission_ratio_q                 # (output/motor)
uint16 motor_encoder_steps_per_revolution   # (0=NA)
uint16 second_encoder_steps_per_revolution  # (0=NA)
float16 potentiometer_gain

uint8 MODE_OPEN_LOOP                =  0  # open loop speed control (voltage control, speed setpoint is in V)
uint8 MODE_INDEX                    =  1  # periodic, speed control with index
uint8 MODE_ENC_PERIODIC             =  2  # periodic, encoder on motor axis
uint8 MODE_ENC_BOUNDED              =  3  # bounded, encoder on motor axis
uint8 MODE_2_ENC_PERIODIC           =  4  # periodic, encoder on motor axis, 2nd encoder on output
uint8 MODE_MOTOR_POT                =  5  # bounded, potentiometer (servo mode)
uint8 mode  # operation mode as defined above
---
******************************************************************************/

/********************* DSDL signature source definition ***********************
motor.config.LoadConfiguration
motor.config.PID position_pid
motor.config.PID velocity_pid
motor.config.PID current_pid
saturated float16 torque_limit
saturated float16 velocity_limit
saturated float16 acceleration_limit
saturated float16 low_batt_th
saturated float16 thermal_capacity
saturated float16 thermal_resistance
saturated float16 thermal_current_gain
saturated float16 max_temperature
saturated float16 torque_constant
saturated uint16 transmission_ratio_p
saturated uint16 transmission_ratio_q
saturated uint16 motor_encoder_steps_per_revolution
saturated uint16 second_encoder_steps_per_revolution
saturated float16 potentiometer_gain
saturated uint8 mode
---
******************************************************************************/

#undef position_pid
#undef velocity_pid
#undef current_pid
#undef torque_limit
#undef velocity_limit
#undef acceleration_limit
#undef low_batt_th
#undef thermal_capacity
#undef thermal_resistance
#undef thermal_current_gain
#undef max_temperature
#undef torque_constant
#undef transmission_ratio_p
#undef transmission_ratio_q
#undef motor_encoder_steps_per_revolution
#undef second_encoder_steps_per_revolution
#undef potentiometer_gain
#undef mode
#undef MODE_OPEN_LOOP
#undef MODE_INDEX
#undef MODE_ENC_PERIODIC
#undef MODE_ENC_BOUNDED
#undef MODE_2_ENC_PERIODIC
#undef MODE_MOTOR_POT

namespace motor
{
namespace config
{

struct UAVCAN_EXPORT LoadConfiguration_
{
    template <int _tmpl>
    struct Request_
    {
        typedef const Request_<_tmpl>& ParameterType;
        typedef Request_<_tmpl>& ReferenceType;

        struct ConstantTypes
        {
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_OPEN_LOOP;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_INDEX;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_ENC_PERIODIC;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_ENC_BOUNDED;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_2_ENC_PERIODIC;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > MODE_MOTOR_POT;
        };

        struct FieldTypes
        {
            typedef ::motor::config::PID position_pid;
            typedef ::motor::config::PID velocity_pid;
            typedef ::motor::config::PID current_pid;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > torque_limit;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > velocity_limit;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > acceleration_limit;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > low_batt_th;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > thermal_capacity;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > thermal_resistance;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > thermal_current_gain;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > max_temperature;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > torque_constant;
            typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > transmission_ratio_p;
            typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > transmission_ratio_q;
            typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > motor_encoder_steps_per_revolution;
            typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > second_encoder_steps_per_revolution;
            typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > potentiometer_gain;
            typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > mode;
        };

        enum
        {
            MinBitLen
                = FieldTypes::position_pid::MinBitLen
                + FieldTypes::velocity_pid::MinBitLen
                + FieldTypes::current_pid::MinBitLen
                + FieldTypes::torque_limit::MinBitLen
                + FieldTypes::velocity_limit::MinBitLen
                + FieldTypes::acceleration_limit::MinBitLen
                + FieldTypes::low_batt_th::MinBitLen
                + FieldTypes::thermal_capacity::MinBitLen
                + FieldTypes::thermal_resistance::MinBitLen
                + FieldTypes::thermal_current_gain::MinBitLen
                + FieldTypes::max_temperature::MinBitLen
                + FieldTypes::torque_constant::MinBitLen
                + FieldTypes::transmission_ratio_p::MinBitLen
                + FieldTypes::transmission_ratio_q::MinBitLen
                + FieldTypes::motor_encoder_steps_per_revolution::MinBitLen
                + FieldTypes::second_encoder_steps_per_revolution::MinBitLen
                + FieldTypes::potentiometer_gain::MinBitLen
                + FieldTypes::mode::MinBitLen
        };

        enum
        {
            MaxBitLen
                = FieldTypes::position_pid::MaxBitLen
                + FieldTypes::velocity_pid::MaxBitLen
                + FieldTypes::current_pid::MaxBitLen
                + FieldTypes::torque_limit::MaxBitLen
                + FieldTypes::velocity_limit::MaxBitLen
                + FieldTypes::acceleration_limit::MaxBitLen
                + FieldTypes::low_batt_th::MaxBitLen
                + FieldTypes::thermal_capacity::MaxBitLen
                + FieldTypes::thermal_resistance::MaxBitLen
                + FieldTypes::thermal_current_gain::MaxBitLen
                + FieldTypes::max_temperature::MaxBitLen
                + FieldTypes::torque_constant::MaxBitLen
                + FieldTypes::transmission_ratio_p::MaxBitLen
                + FieldTypes::transmission_ratio_q::MaxBitLen
                + FieldTypes::motor_encoder_steps_per_revolution::MaxBitLen
                + FieldTypes::second_encoder_steps_per_revolution::MaxBitLen
                + FieldTypes::potentiometer_gain::MaxBitLen
                + FieldTypes::mode::MaxBitLen
        };

        // Constants
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_OPEN_LOOP >::Type MODE_OPEN_LOOP; // 0
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_INDEX >::Type MODE_INDEX; // 1
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_ENC_PERIODIC >::Type MODE_ENC_PERIODIC; // 2
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_ENC_BOUNDED >::Type MODE_ENC_BOUNDED; // 3
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_2_ENC_PERIODIC >::Type MODE_2_ENC_PERIODIC; // 4
        static const typename ::uavcan::StorageType< typename ConstantTypes::MODE_MOTOR_POT >::Type MODE_MOTOR_POT; // 5

        // Fields
        typename ::uavcan::StorageType< typename FieldTypes::position_pid >::Type position_pid;
        typename ::uavcan::StorageType< typename FieldTypes::velocity_pid >::Type velocity_pid;
        typename ::uavcan::StorageType< typename FieldTypes::current_pid >::Type current_pid;
        typename ::uavcan::StorageType< typename FieldTypes::torque_limit >::Type torque_limit;
        typename ::uavcan::StorageType< typename FieldTypes::velocity_limit >::Type velocity_limit;
        typename ::uavcan::StorageType< typename FieldTypes::acceleration_limit >::Type acceleration_limit;
        typename ::uavcan::StorageType< typename FieldTypes::low_batt_th >::Type low_batt_th;
        typename ::uavcan::StorageType< typename FieldTypes::thermal_capacity >::Type thermal_capacity;
        typename ::uavcan::StorageType< typename FieldTypes::thermal_resistance >::Type thermal_resistance;
        typename ::uavcan::StorageType< typename FieldTypes::thermal_current_gain >::Type thermal_current_gain;
        typename ::uavcan::StorageType< typename FieldTypes::max_temperature >::Type max_temperature;
        typename ::uavcan::StorageType< typename FieldTypes::torque_constant >::Type torque_constant;
        typename ::uavcan::StorageType< typename FieldTypes::transmission_ratio_p >::Type transmission_ratio_p;
        typename ::uavcan::StorageType< typename FieldTypes::transmission_ratio_q >::Type transmission_ratio_q;
        typename ::uavcan::StorageType< typename FieldTypes::motor_encoder_steps_per_revolution >::Type motor_encoder_steps_per_revolution;
        typename ::uavcan::StorageType< typename FieldTypes::second_encoder_steps_per_revolution >::Type second_encoder_steps_per_revolution;
        typename ::uavcan::StorageType< typename FieldTypes::potentiometer_gain >::Type potentiometer_gain;
        typename ::uavcan::StorageType< typename FieldTypes::mode >::Type mode;

        Request_()
            : position_pid()
            , velocity_pid()
            , current_pid()
            , torque_limit()
            , velocity_limit()
            , acceleration_limit()
            , low_batt_th()
            , thermal_capacity()
            , thermal_resistance()
            , thermal_current_gain()
            , max_temperature()
            , torque_constant()
            , transmission_ratio_p()
            , transmission_ratio_q()
            , motor_encoder_steps_per_revolution()
            , second_encoder_steps_per_revolution()
            , potentiometer_gain()
            , mode()
        {
            ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

    #if UAVCAN_DEBUG
            /*
             * Cross-checking MaxBitLen provided by the DSDL compiler.
             * This check shall never be performed in user code because MaxBitLen value
             * actually depends on the nested types, thus it is not invariant.
             */
            ::uavcan::StaticAssert<424 == MaxBitLen>::check();
    #endif
        }

        bool operator==(ParameterType rhs) const;
        bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

        /**
         * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
         * floating point fields at any depth.
         */
        bool isClose(ParameterType rhs) const;

        static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                          ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

        static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                          ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    };

    template <int _tmpl>
    struct Response_
    {
        typedef const Response_<_tmpl>& ParameterType;
        typedef Response_<_tmpl>& ReferenceType;

        struct ConstantTypes
        {
        };

        struct FieldTypes
        {
        };

        enum
        {
            MinBitLen
        };

        enum
        {
            MaxBitLen
        };

        // Constants

        // Fields

        Response_()
        {
            ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

    #if UAVCAN_DEBUG
            /*
             * Cross-checking MaxBitLen provided by the DSDL compiler.
             * This check shall never be performed in user code because MaxBitLen value
             * actually depends on the nested types, thus it is not invariant.
             */
            ::uavcan::StaticAssert<0 == MaxBitLen>::check();
    #endif
        }

        bool operator==(ParameterType rhs) const;
        bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

        /**
         * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
         * floating point fields at any depth.
         */
        bool isClose(ParameterType rhs) const;

        static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                          ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

        static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                          ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    };

    typedef Request_<0> Request;
    typedef Response_<0> Response;

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindService };
    enum { DefaultDataTypeID = 210 };

    static const char* getDataTypeFullName()
    {
        return "motor.config.LoadConfiguration";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

private:
    LoadConfiguration_(); // Don't create objects of this type. Use Request/Response instead.
};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool LoadConfiguration_::Request_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        position_pid == rhs.position_pid &&
        velocity_pid == rhs.velocity_pid &&
        current_pid == rhs.current_pid &&
        torque_limit == rhs.torque_limit &&
        velocity_limit == rhs.velocity_limit &&
        acceleration_limit == rhs.acceleration_limit &&
        low_batt_th == rhs.low_batt_th &&
        thermal_capacity == rhs.thermal_capacity &&
        thermal_resistance == rhs.thermal_resistance &&
        thermal_current_gain == rhs.thermal_current_gain &&
        max_temperature == rhs.max_temperature &&
        torque_constant == rhs.torque_constant &&
        transmission_ratio_p == rhs.transmission_ratio_p &&
        transmission_ratio_q == rhs.transmission_ratio_q &&
        motor_encoder_steps_per_revolution == rhs.motor_encoder_steps_per_revolution &&
        second_encoder_steps_per_revolution == rhs.second_encoder_steps_per_revolution &&
        potentiometer_gain == rhs.potentiometer_gain &&
        mode == rhs.mode;
}

template <int _tmpl>
bool LoadConfiguration_::Request_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(position_pid, rhs.position_pid) &&
        ::uavcan::areClose(velocity_pid, rhs.velocity_pid) &&
        ::uavcan::areClose(current_pid, rhs.current_pid) &&
        ::uavcan::areClose(torque_limit, rhs.torque_limit) &&
        ::uavcan::areClose(velocity_limit, rhs.velocity_limit) &&
        ::uavcan::areClose(acceleration_limit, rhs.acceleration_limit) &&
        ::uavcan::areClose(low_batt_th, rhs.low_batt_th) &&
        ::uavcan::areClose(thermal_capacity, rhs.thermal_capacity) &&
        ::uavcan::areClose(thermal_resistance, rhs.thermal_resistance) &&
        ::uavcan::areClose(thermal_current_gain, rhs.thermal_current_gain) &&
        ::uavcan::areClose(max_temperature, rhs.max_temperature) &&
        ::uavcan::areClose(torque_constant, rhs.torque_constant) &&
        ::uavcan::areClose(transmission_ratio_p, rhs.transmission_ratio_p) &&
        ::uavcan::areClose(transmission_ratio_q, rhs.transmission_ratio_q) &&
        ::uavcan::areClose(motor_encoder_steps_per_revolution, rhs.motor_encoder_steps_per_revolution) &&
        ::uavcan::areClose(second_encoder_steps_per_revolution, rhs.second_encoder_steps_per_revolution) &&
        ::uavcan::areClose(potentiometer_gain, rhs.potentiometer_gain) &&
        ::uavcan::areClose(mode, rhs.mode);
}

template <int _tmpl>
int LoadConfiguration_::Request_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::position_pid::encode(self.position_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_pid::encode(self.velocity_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::current_pid::encode(self.current_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::torque_limit::encode(self.torque_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_limit::encode(self.velocity_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::acceleration_limit::encode(self.acceleration_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::low_batt_th::encode(self.low_batt_th, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_capacity::encode(self.thermal_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_resistance::encode(self.thermal_resistance, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_current_gain::encode(self.thermal_current_gain, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::max_temperature::encode(self.max_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::torque_constant::encode(self.torque_constant, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::transmission_ratio_p::encode(self.transmission_ratio_p, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::transmission_ratio_q::encode(self.transmission_ratio_q, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::motor_encoder_steps_per_revolution::encode(self.motor_encoder_steps_per_revolution, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::second_encoder_steps_per_revolution::encode(self.second_encoder_steps_per_revolution, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::potentiometer_gain::encode(self.potentiometer_gain, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::mode::encode(self.mode, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int LoadConfiguration_::Request_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::position_pid::decode(self.position_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_pid::decode(self.velocity_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::current_pid::decode(self.current_pid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::torque_limit::decode(self.torque_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_limit::decode(self.velocity_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::acceleration_limit::decode(self.acceleration_limit, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::low_batt_th::decode(self.low_batt_th, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_capacity::decode(self.thermal_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_resistance::decode(self.thermal_resistance, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::thermal_current_gain::decode(self.thermal_current_gain, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::max_temperature::decode(self.max_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::torque_constant::decode(self.torque_constant, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::transmission_ratio_p::decode(self.transmission_ratio_p, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::transmission_ratio_q::decode(self.transmission_ratio_q, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::motor_encoder_steps_per_revolution::decode(self.motor_encoder_steps_per_revolution, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::second_encoder_steps_per_revolution::decode(self.second_encoder_steps_per_revolution, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::potentiometer_gain::decode(self.potentiometer_gain, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::mode::decode(self.mode, codec,  tao_mode);
    return res;
}

template <int _tmpl>
bool LoadConfiguration_::Response_<_tmpl>::operator==(ParameterType rhs) const
{
    (void)rhs;
    return true;
}

template <int _tmpl>
bool LoadConfiguration_::Response_<_tmpl>::isClose(ParameterType rhs) const
{
    (void)rhs;
    return true;
}

template <int _tmpl>
int LoadConfiguration_::Response_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    return res;
}

template <int _tmpl>
int LoadConfiguration_::Response_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    return res;
}

/*
 * Out of line type method definitions
 */
inline ::uavcan::DataTypeSignature LoadConfiguration_::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x4C8B072A20F4589AULL);

    Request::FieldTypes::position_pid::extendDataTypeSignature(signature);
    Request::FieldTypes::velocity_pid::extendDataTypeSignature(signature);
    Request::FieldTypes::current_pid::extendDataTypeSignature(signature);
    Request::FieldTypes::torque_limit::extendDataTypeSignature(signature);
    Request::FieldTypes::velocity_limit::extendDataTypeSignature(signature);
    Request::FieldTypes::acceleration_limit::extendDataTypeSignature(signature);
    Request::FieldTypes::low_batt_th::extendDataTypeSignature(signature);
    Request::FieldTypes::thermal_capacity::extendDataTypeSignature(signature);
    Request::FieldTypes::thermal_resistance::extendDataTypeSignature(signature);
    Request::FieldTypes::thermal_current_gain::extendDataTypeSignature(signature);
    Request::FieldTypes::max_temperature::extendDataTypeSignature(signature);
    Request::FieldTypes::torque_constant::extendDataTypeSignature(signature);
    Request::FieldTypes::transmission_ratio_p::extendDataTypeSignature(signature);
    Request::FieldTypes::transmission_ratio_q::extendDataTypeSignature(signature);
    Request::FieldTypes::motor_encoder_steps_per_revolution::extendDataTypeSignature(signature);
    Request::FieldTypes::second_encoder_steps_per_revolution::extendDataTypeSignature(signature);
    Request::FieldTypes::potentiometer_gain::extendDataTypeSignature(signature);
    Request::FieldTypes::mode::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_OPEN_LOOP >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_OPEN_LOOP = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_INDEX >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_INDEX = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_ENC_PERIODIC >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_ENC_PERIODIC = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_ENC_BOUNDED >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_ENC_BOUNDED = 3U; // 3

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_2_ENC_PERIODIC >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_2_ENC_PERIODIC = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename LoadConfiguration_::Request_<_tmpl>::ConstantTypes::MODE_MOTOR_POT >::Type
    LoadConfiguration_::Request_<_tmpl>::MODE_MOTOR_POT = 5U; // 5

/*
 * Final typedef
 */
typedef LoadConfiguration_ LoadConfiguration;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::motor::config::LoadConfiguration > _uavcan_gdtr_registrator_LoadConfiguration;

}

} // Namespace config
} // Namespace motor

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::motor::config::LoadConfiguration::Request >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::motor::config::LoadConfiguration::Request::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::motor::config::LoadConfiguration::Request >::stream(Stream& s, ::motor::config::LoadConfiguration::Request::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "position_pid: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::position_pid >::stream(s, obj.position_pid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "velocity_pid: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::velocity_pid >::stream(s, obj.velocity_pid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "current_pid: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::current_pid >::stream(s, obj.current_pid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "torque_limit: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::torque_limit >::stream(s, obj.torque_limit, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "velocity_limit: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::velocity_limit >::stream(s, obj.velocity_limit, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "acceleration_limit: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::acceleration_limit >::stream(s, obj.acceleration_limit, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "low_batt_th: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::low_batt_th >::stream(s, obj.low_batt_th, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "thermal_capacity: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::thermal_capacity >::stream(s, obj.thermal_capacity, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "thermal_resistance: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::thermal_resistance >::stream(s, obj.thermal_resistance, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "thermal_current_gain: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::thermal_current_gain >::stream(s, obj.thermal_current_gain, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "max_temperature: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::max_temperature >::stream(s, obj.max_temperature, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "torque_constant: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::torque_constant >::stream(s, obj.torque_constant, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "transmission_ratio_p: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::transmission_ratio_p >::stream(s, obj.transmission_ratio_p, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "transmission_ratio_q: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::transmission_ratio_q >::stream(s, obj.transmission_ratio_q, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "motor_encoder_steps_per_revolution: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::motor_encoder_steps_per_revolution >::stream(s, obj.motor_encoder_steps_per_revolution, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "second_encoder_steps_per_revolution: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::second_encoder_steps_per_revolution >::stream(s, obj.second_encoder_steps_per_revolution, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "potentiometer_gain: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::potentiometer_gain >::stream(s, obj.potentiometer_gain, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "mode: ";
    YamlStreamer< ::motor::config::LoadConfiguration::Request::FieldTypes::mode >::stream(s, obj.mode, level + 1);
}

template <>
class UAVCAN_EXPORT YamlStreamer< ::motor::config::LoadConfiguration::Response >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::motor::config::LoadConfiguration::Response::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::motor::config::LoadConfiguration::Response >::stream(Stream& s, ::motor::config::LoadConfiguration::Response::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
}

}

namespace motor
{
namespace config
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::motor::config::LoadConfiguration::Request::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::motor::config::LoadConfiguration::Request >::stream(s, obj, 0);
    return s;
}

template <typename Stream>
inline Stream& operator<<(Stream& s, ::motor::config::LoadConfiguration::Response::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::motor::config::LoadConfiguration::Response >::stream(s, obj, 0);
    return s;
}

} // Namespace config
} // Namespace motor

#endif // MOTOR_CONFIG_LOADCONFIGURATION_HPP_INCLUDED